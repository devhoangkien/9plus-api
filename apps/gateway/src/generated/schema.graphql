schema {
  query: Query
  mutation: Mutation
}

directive @composeDirective(name: String) on SCHEMA

directive @extends on INTERFACE | OBJECT

directive @external(reason: String) on FIELD_DEFINITION | OBJECT

directive @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION

directive @interfaceObject on OBJECT

directive @key(fields: federation__FieldSet!, resolvable: Boolean = true) on INTERFACE | OBJECT

directive @link(as: String, for: link__Purpose, import: [link__Import], url: String) on SCHEMA

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: federation__FieldSet!) on FIELD_DEFINITION

directive @requires(fields: federation__FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

directive @tag(name: String!) on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | SCHEMA | UNION

input CheckUserExistDto {
  email: String
  phone: String
  username: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

enum GenderEnum {
  FEMALE
  MALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum LoginMethod {
  APPLE
  FACEBOOK
  GOOGLE
  LOCAL
  MICROSOFT
  SSO
}

type LoginResponse {
  accessToken: String!
  refreshToken: String!
  requiresTwoFactor: Boolean
  user: User
  userId: String!
}

input LoginUserInput {
  email: String!
  password: String!
}

type Mutation {
  changePassword(currentPassword: String!, newPassword: String!): Boolean!
  disableTwoFactor(password: String!): Boolean!
  enableTwoFactor(token: String!): Boolean!
  login(input: LoginUserInput!): LoginResponse!
  logout: Boolean!
  refreshToken(refreshToken: String!): LoginResponse!
  register(input: RegisterUserInput!): User!
  requestPasswordReset(email: String!): Boolean!
  resetPassword(newPassword: String!, token: String!): Boolean!
  setupTwoFactor: String!
  verifyTwoFactor(token: String!, userId: String!): LoginResponse!
}

type Permission {
  _count: PermissionCount!
  action: String!
  createdAt: DateTime!
  createdBy: String
  description: String
  id: ID!
  key: String!
  name: String!
  resource: String!
  roles: [Role!]
  scope: String!
  status: PermissionStatusEnum!
  updatedAt: DateTime!
  updatedBy: String
}

type PermissionCount {
  roles: Int!
}

type PermissionCountAggregate {
  _all: Int!
  action: Int!
  createdAt: Int!
  createdBy: Int!
  description: Int!
  id: Int!
  key: Int!
  name: Int!
  resource: Int!
  scope: Int!
  status: Int!
  updatedAt: Int!
  updatedBy: Int!
}

type PermissionMaxAggregate {
  action: String
  createdAt: DateTime
  createdBy: String
  description: String
  id: String
  key: String
  name: String
  resource: String
  scope: String
  status: PermissionStatusEnum
  updatedAt: DateTime
  updatedBy: String
}

type PermissionMinAggregate {
  action: String
  createdAt: DateTime
  createdBy: String
  description: String
  id: String
  key: String
  name: String
  resource: String
  scope: String
  status: PermissionStatusEnum
  updatedAt: DateTime
  updatedBy: String
}

enum PermissionStatusEnum {
  ACTIVE
  ARCHIVED
  DEPRECATED
  INACTIVE
}

type Query {
  checkUserExists(data: CheckUserExistDto!): Boolean!
  getRoleByKey(key: String!): Role!
  getRolesByKeys(keys: String!): [Role!]!
  me: User!
  validateToken: Boolean!
}

input RegisterUserInput {
  email: String!
  password: String!
}

type Role {
  _count: RoleCount!
  createdAt: DateTime!
  createdBy: String
  description: String
  id: ID!
  isSystemRole: Boolean!
  key: String!
  level: Int!
  name: String!
  permissions: [Permission!]
  status: RoleStatusEnum!
  updatedAt: DateTime!
  updatedBy: String
  users: [User!]
}

type RoleAvgAggregate {
  level: Float
}

type RoleCount {
  permissions: Int!
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  createdAt: Int!
  createdBy: Int!
  description: Int!
  id: Int!
  isSystemRole: Int!
  key: Int!
  level: Int!
  name: Int!
  status: Int!
  updatedAt: Int!
  updatedBy: Int!
}

type RoleMaxAggregate {
  createdAt: DateTime
  createdBy: String
  description: String
  id: String
  isSystemRole: Boolean
  key: String
  level: Int
  name: String
  status: RoleStatusEnum
  updatedAt: DateTime
  updatedBy: String
}

type RoleMinAggregate {
  createdAt: DateTime
  createdBy: String
  description: String
  id: String
  isSystemRole: Boolean
  key: String
  level: Int
  name: String
  status: RoleStatusEnum
  updatedAt: DateTime
  updatedBy: String
}

enum RoleStatusEnum {
  ACTIVE
  ARCHIVED
  DEPRECATED
  INACTIVE
}

type RoleSumAggregate {
  level: Int
}

type User {
  _count: UserCount!
  address: String
  avatar: String
  createdAt: DateTime!
  createdBy: String
  dateOfBirth: DateTime
  deletedAt: DateTime
  email: String!
  emailVerificationExpires: DateTime
  emailVerificationToken: String
  emailVerified: Boolean!
  failedLoginAttempts: Int!
  firstName: String
  fullName: String
  gender: GenderEnum
  id: ID!
  isFirstLogin: Boolean!
  lastLogin: DateTime
  lastLoginIP: String
  lastName: String
  lockoutExpires: DateTime
  loginMethod: LoginMethod!
  passwordResetExpires: DateTime
  passwordResetToken: String
  phone: String
  phoneVerified: Boolean!
  roles: [Role!]
  status: UserStatusEnum!
  twoFactorEnabled: Boolean!
  twoFactorSecret: String
  updatedAt: DateTime!
  updatedBy: String
  userSessions: [UserSession!]
  username: String!
}

type UserAvgAggregate {
  failedLoginAttempts: Float
}

type UserCount {
  roles: Int!
  userSessions: Int!
}

type UserCountAggregate {
  _all: Int!
  address: Int!
  avatar: Int!
  createdAt: Int!
  createdBy: Int!
  dateOfBirth: Int!
  deletedAt: Int!
  email: Int!
  emailVerificationExpires: Int!
  emailVerificationToken: Int!
  emailVerified: Int!
  failedLoginAttempts: Int!
  firstName: Int!
  fullName: Int!
  gender: Int!
  id: Int!
  isFirstLogin: Int!
  lastLogin: Int!
  lastLoginIP: Int!
  lastName: Int!
  lockoutExpires: Int!
  loginMethod: Int!
  passwordResetExpires: Int!
  passwordResetToken: Int!
  phone: Int!
  phoneVerified: Int!
  status: Int!
  twoFactorEnabled: Int!
  twoFactorSecret: Int!
  updatedAt: Int!
  updatedBy: Int!
  username: Int!
}

type UserMaxAggregate {
  address: String
  avatar: String
  createdAt: DateTime
  createdBy: String
  dateOfBirth: DateTime
  deletedAt: DateTime
  email: String
  emailVerificationExpires: DateTime
  emailVerificationToken: String
  emailVerified: Boolean
  failedLoginAttempts: Int
  firstName: String
  fullName: String
  gender: GenderEnum
  id: String
  isFirstLogin: Boolean
  lastLogin: DateTime
  lastLoginIP: String
  lastName: String
  lockoutExpires: DateTime
  loginMethod: LoginMethod
  passwordResetExpires: DateTime
  passwordResetToken: String
  phone: String
  phoneVerified: Boolean
  status: UserStatusEnum
  twoFactorEnabled: Boolean
  twoFactorSecret: String
  updatedAt: DateTime
  updatedBy: String
  username: String
}

type UserMinAggregate {
  address: String
  avatar: String
  createdAt: DateTime
  createdBy: String
  dateOfBirth: DateTime
  deletedAt: DateTime
  email: String
  emailVerificationExpires: DateTime
  emailVerificationToken: String
  emailVerified: Boolean
  failedLoginAttempts: Int
  firstName: String
  fullName: String
  gender: GenderEnum
  id: String
  isFirstLogin: Boolean
  lastLogin: DateTime
  lastLoginIP: String
  lastName: String
  lockoutExpires: DateTime
  loginMethod: LoginMethod
  passwordResetExpires: DateTime
  passwordResetToken: String
  phone: String
  phoneVerified: Boolean
  status: UserStatusEnum
  twoFactorEnabled: Boolean
  twoFactorSecret: String
  updatedAt: DateTime
  updatedBy: String
  username: String
}

type UserSession {
  createdAt: DateTime!
  deviceInfo: String
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  isActive: Boolean!
  lastActivity: DateTime!
  refreshToken: String
  sessionToken: String!
  updatedAt: DateTime!
  user: User!
  userAgent: String
  userId: String!
}

type UserSessionCountAggregate {
  _all: Int!
  createdAt: Int!
  deviceInfo: Int!
  expiresAt: Int!
  id: Int!
  ipAddress: Int!
  isActive: Int!
  lastActivity: Int!
  refreshToken: Int!
  sessionToken: Int!
  updatedAt: Int!
  userAgent: Int!
  userId: Int!
}

type UserSessionMaxAggregate {
  createdAt: DateTime
  deviceInfo: String
  expiresAt: DateTime
  id: String
  ipAddress: String
  isActive: Boolean
  lastActivity: DateTime
  refreshToken: String
  sessionToken: String
  updatedAt: DateTime
  userAgent: String
  userId: String
}

type UserSessionMinAggregate {
  createdAt: DateTime
  deviceInfo: String
  expiresAt: DateTime
  id: String
  ipAddress: String
  isActive: Boolean
  lastActivity: DateTime
  refreshToken: String
  sessionToken: String
  updatedAt: DateTime
  userAgent: String
  userId: String
}

enum UserStatusEnum {
  ACTIVE
  ARCHIVED
  INACTIVE
  LOCKED
  PENDING_VERIFICATION
  SUSPENDED
}

type UserSumAggregate {
  failedLoginAttempts: Int
}

scalar _Any

scalar federation__FieldSet

scalar link__Import

enum link__Purpose {
  """
  `EXECUTION` features provide metadata necessary for operation execution.
  """
  EXECUTION
  """
  `SECURITY` features provide metadata necessary to securely resolve fields.
  """
  SECURITY
}