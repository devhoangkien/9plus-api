# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type PermissionCountAggregate {
  id: Int!
  name: Int!
  key: Int!
  description: Int!
  resource: Int!
  action: Int!
  scope: Int!
  status: Int!
  createdAt: Int!
  updatedAt: Int!
  createdBy: Int!
  updatedBy: Int!
  _all: Int!
}

type PermissionCount {
  roles: Int!
}

type PermissionMaxAggregate {
  id: String
  name: String
  key: String
  description: String
  resource: String
  action: String
  scope: String
  status: PermissionStatusEnum
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: String
  updatedBy: String
}

enum PermissionStatusEnum {
  ACTIVE
  INACTIVE
  DEPRECATED
  ARCHIVED
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type PermissionMinAggregate {
  id: String
  name: String
  key: String
  description: String
  resource: String
  action: String
  scope: String
  status: PermissionStatusEnum
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: String
  updatedBy: String
}

type Permission {
  id: ID!
  name: String!
  key: String!
  description: String
  resource: String!
  action: String!
  scope: String!
  status: PermissionStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: String
  updatedBy: String
  roles: [Role!]
  _count: PermissionCount!
}

type RoleAvgAggregate {
  level: Float
}

type RoleCountAggregate {
  id: Int!
  name: Int!
  key: Int!
  description: Int!
  level: Int!
  isSystemRole: Int!
  status: Int!
  createdAt: Int!
  updatedAt: Int!
  createdBy: Int!
  updatedBy: Int!
  _all: Int!
}

type RoleCount {
  permissions: Int!
  users: Int!
}

type RoleMaxAggregate {
  id: String
  name: String
  key: String
  description: String
  level: Int
  isSystemRole: Boolean
  status: RoleStatusEnum
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: String
  updatedBy: String
}

enum RoleStatusEnum {
  ACTIVE
  INACTIVE
  DEPRECATED
  ARCHIVED
}

type RoleMinAggregate {
  id: String
  name: String
  key: String
  description: String
  level: Int
  isSystemRole: Boolean
  status: RoleStatusEnum
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: String
  updatedBy: String
}

type RoleSumAggregate {
  level: Int
}

type Role {
  id: ID!
  name: String!
  key: String!
  description: String
  level: Int!
  isSystemRole: Boolean!
  status: RoleStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: String
  updatedBy: String
  permissions: [Permission!]
  users: [User!]
  _count: RoleCount!
}

type UserAvgAggregate {
  failedLoginAttempts: Float
}

type UserCountAggregate {
  id: Int!
  email: Int!
  phone: Int!
  username: Int!
  firstName: Int!
  lastName: Int!
  fullName: Int!
  avatar: Int!
  dateOfBirth: Int!
  gender: Int!
  address: Int!
  status: Int!
  emailVerified: Int!
  phoneVerified: Int!
  twoFactorEnabled: Int!
  isFirstLogin: Int!
  loginMethod: Int!
  lastLogin: Int!
  lastLoginIP: Int!
  passwordResetToken: Int!
  passwordResetExpires: Int!
  emailVerificationToken: Int!
  emailVerificationExpires: Int!
  failedLoginAttempts: Int!
  lockoutExpires: Int!
  twoFactorSecret: Int!
  createdAt: Int!
  updatedAt: Int!
  deletedAt: Int!
  createdBy: Int!
  updatedBy: Int!
  _all: Int!
}

type UserCount {
  userSessions: Int!
  roles: Int!
}

type UserMaxAggregate {
  id: String
  email: String
  phone: String
  username: String
  firstName: String
  lastName: String
  fullName: String
  avatar: String
  dateOfBirth: DateTime
  gender: GenderEnum
  address: String
  status: UserStatusEnum
  emailVerified: Boolean
  phoneVerified: Boolean
  twoFactorEnabled: Boolean
  isFirstLogin: Boolean
  loginMethod: LoginMethod
  lastLogin: DateTime
  lastLoginIP: String
  passwordResetToken: String
  passwordResetExpires: DateTime
  emailVerificationToken: String
  emailVerificationExpires: DateTime
  failedLoginAttempts: Int
  lockoutExpires: DateTime
  twoFactorSecret: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: String
  updatedBy: String
}

enum GenderEnum {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum UserStatusEnum {
  ACTIVE
  INACTIVE
  SUSPENDED
  LOCKED
  PENDING_VERIFICATION
  ARCHIVED
}

enum LoginMethod {
  LOCAL
  GOOGLE
  FACEBOOK
  MICROSOFT
  APPLE
  SSO
}

type UserMinAggregate {
  id: String
  email: String
  phone: String
  username: String
  firstName: String
  lastName: String
  fullName: String
  avatar: String
  dateOfBirth: DateTime
  gender: GenderEnum
  address: String
  status: UserStatusEnum
  emailVerified: Boolean
  phoneVerified: Boolean
  twoFactorEnabled: Boolean
  isFirstLogin: Boolean
  loginMethod: LoginMethod
  lastLogin: DateTime
  lastLoginIP: String
  passwordResetToken: String
  passwordResetExpires: DateTime
  emailVerificationToken: String
  emailVerificationExpires: DateTime
  failedLoginAttempts: Int
  lockoutExpires: DateTime
  twoFactorSecret: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: String
  updatedBy: String
}

type UserSumAggregate {
  failedLoginAttempts: Int
}

type User {
  id: ID!
  email: String!
  phone: String
  username: String!
  firstName: String
  lastName: String
  fullName: String
  avatar: String
  dateOfBirth: DateTime
  gender: GenderEnum
  address: String
  status: UserStatusEnum!
  emailVerified: Boolean!
  phoneVerified: Boolean!
  twoFactorEnabled: Boolean!
  isFirstLogin: Boolean!
  loginMethod: LoginMethod!
  lastLogin: DateTime
  lastLoginIP: String
  passwordResetToken: String
  passwordResetExpires: DateTime
  emailVerificationToken: String
  emailVerificationExpires: DateTime
  failedLoginAttempts: Int!
  lockoutExpires: DateTime
  twoFactorSecret: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  createdBy: String
  updatedBy: String
  userSessions: [UserSession!]
  roles: [Role!]
  _count: UserCount!
}

type UserSessionCountAggregate {
  id: Int!
  userId: Int!
  sessionToken: Int!
  refreshToken: Int!
  deviceInfo: Int!
  ipAddress: Int!
  userAgent: Int!
  isActive: Int!
  expiresAt: Int!
  createdAt: Int!
  updatedAt: Int!
  lastActivity: Int!
  _all: Int!
}

type UserSessionMaxAggregate {
  id: String
  userId: String
  sessionToken: String
  refreshToken: String
  deviceInfo: String
  ipAddress: String
  userAgent: String
  isActive: Boolean
  expiresAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  lastActivity: DateTime
}

type UserSessionMinAggregate {
  id: String
  userId: String
  sessionToken: String
  refreshToken: String
  deviceInfo: String
  ipAddress: String
  userAgent: String
  isActive: Boolean
  expiresAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  lastActivity: DateTime
}

type UserSession {
  id: ID!
  userId: String!
  sessionToken: String!
  refreshToken: String
  deviceInfo: String
  ipAddress: String
  userAgent: String
  isActive: Boolean!
  expiresAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastActivity: DateTime!
  user: User!
}

type LoginResponse {
  accessToken: String!
  refreshToken: String!
  userId: String!
  user: User
  requiresTwoFactor: Boolean
}

type Query {
  me: User!
  validateToken: Boolean!
  checkUserExists(data: CheckUserExistDto!): Boolean!
  getRoleByKey(key: String!): Role!
  getRolesByKeys(keys: String!): [Role!]!
}

input CheckUserExistDto {
  email: String
  phone: String
  username: String
}

type Mutation {
  register(input: RegisterUserInput!): User!
  login(input: LoginUserInput!): LoginResponse!
  verifyTwoFactor(userId: String!, token: String!): LoginResponse!
  refreshToken(refreshToken: String!): LoginResponse!
  logout: Boolean!
  changePassword(currentPassword: String!, newPassword: String!): Boolean!
  requestPasswordReset(email: String!): Boolean!
  resetPassword(token: String!, newPassword: String!): Boolean!
  setupTwoFactor: String!
  enableTwoFactor(token: String!): Boolean!
  disableTwoFactor(password: String!): Boolean!
}

input RegisterUserInput {
  email: String!
  password: String!
}

input LoginUserInput {
  email: String!
  password: String!
}