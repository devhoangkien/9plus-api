input {
  beats {
    port => 5044
  }
  
  # HTTP input for manual log shipping
  http {
    port => 5000
    codec => json
  }
  
  # TCP input for structured logs
  tcp {
    port => 5001
    codec => json_lines
  }
}

filter {
  # Add common fields
  mutate {
    add_field => { "[@metadata][index_prefix]" => "anineplus-logs" }
  }
  
  # Parse timestamp if present
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }
  
  # Parse log level
  if [level] {
    mutate {
      lowercase => [ "level" ]
    }
  }
  
  # Add service information from source or beats input
  if [fields][service] {
    mutate {
      add_field => { "service" => "%{[fields][service]}" }
    }
  } else if [source] and [source] =~ /.*\/(.+)\/logs\/.+/ {
    grok {
      match => { "source" => ".*/(?<service>[^/]+)/logs/.+" }
    }
  }
  
  # Parse structured logs from JSON
  if [message] and [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }
    
    if [parsed] {
      mutate {
        replace => { "level" => "%{[parsed][level]}" }
        replace => { "message" => "%{[parsed][message]}" }
        add_field => { "structured" => true }
      }
      
      # Copy additional fields from parsed JSON
      ruby {
        code => "
          parsed = event.get('parsed')
          if parsed.is_a?(Hash)
            parsed.each do |key, value|
              next if ['level', 'message', 'timestamp'].include?(key)
              event.set(key, value)
            end
          end
        "
      }
    }
  }
  
  # Grok patterns for common log formats
  if ![structured] {
    grok {
      match => { 
        "message" => [
          "%{TIMESTAMP_ISO8601:log_timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}",
          "\[%{TIMESTAMP_ISO8601:log_timestamp}\] %{LOGLEVEL:log_level}: %{GREEDYDATA:log_message}",
          "%{COMBINEDAPACHELOG}"
        ]
      }
      tag_on_failure => ["_grokparsefailure"]
    }
    
    if [log_level] {
      mutate {
        replace => { "level" => "%{log_level}" }
        lowercase => [ "level" ]
      }
    }
    
    if [log_message] {
      mutate {
        replace => { "message" => "%{log_message}" }
      }
    }
  }
  
  # Remove temporary fields
  mutate {
    remove_field => [ "parsed", "log_level", "log_message", "log_timestamp" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    user => "elastic"
    password => "changeme"
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    template_name => "anineplus-logs"
    template_pattern => "anineplus-logs-*"
    template => "/usr/share/logstash/templates/logstash.json"
    template_overwrite => true
  }
  
  # Debug output (remove in production)
  stdout { 
    codec => rubydebug {
      metadata => true
    }
  }
}